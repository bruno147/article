\section{Background}\label{sec:2}

Scientific Research has been greatly aided by the evolution of simulators, which greatly simplify and reduce initial development costs. These tools have been widely used in several areas, such as medical education~\cite{MEDIC}, aiding decision making~\cite{useOfSimulaton2002}, aviation industry~\cite{AIR}, and automotive research and development~\cite{AUTR}. In the field of Machine Learning, simulations are specially helpful for training and learning through experimentation.

Car simulators model several elements of a vehicular dynamics, including inertia, suspension types, differentials, friction, aerodynamics, and others~\cite{SIMUTORCS}. These models represent an approximation of real systems, and the reality gap (differences between model and real system results~\cite{brookes2012authentic}) that stems from the simplifications made have to be considered, so simulations cannot completely replace experimentation on actual cars. However, current advanced simulators provide such realistic experiences that they are ideal for most of the development phase.

\subsection{TORCS \& SCR}
The Open Racing Car Simulator\footnote{\url{http://torcs.sourceforge.net/}} is a platform that is renowned for its highly credible physics modeling engine and yet user-friendly interface with very customizable environment for car racing simulations~\cite{SIMUTORCS,SCR}, and has widely used in Artificial Intelligence (AI) for developing and comparing solutions~\cite{2009}. It considers factors such as collision, traction, aerodynamics, and fuel consumption and provides several circuits, vehicles, and controllers~\cite{2009,Loiacono:2012:LEA:2212908.2212953}, enabling all kinds of possible in-game situations. Additionally, it is open source, with an active community, making it possible and encouraging modifications of its source code to better suit specific needs. It has been used as a standard platform for simulated racing since 2007~\cite{Loiacono:2012:LEA:2212908.2212953}.

TORCS tracks\footnote{\url{http://www.berniw.org/trb/tracks/tracklist.php}} differ in categorization according to the surface they simulate. There are three types of tracks available: \emph{road}, \emph{oval}, and \emph{dirt}, each with its own features that affect the dynamics of the cars in execution time. There are also several cars available\footnote{\url{http://www.berniw.org/trb/cars/carlist.php}} for use, each with its specific weight, suspension, differentials, tires, aerodynamic and other properties~\cite{SIMUTORCS}. The AI opponents controlled available with TORCS are \emph{robots}, and they are linked to the game engine and have access to its internal model. External drivers are called \emph{controllers}, and can these can be dynamically linked to the game engine, like the robots, or communicate through the SCR interface.

The Simulated Car Racing Championship (SCR) is a competition between controllers built on TORCS~\cite{SCR}. It was the first simulated car racing championship organized as a joined event of major scientific conferences: IEEE Congress on Evolutionary Computation, the ACM Genetic and Evolutionary Computation Conference, and the IEEE Symposium on Computational Intelligence and Games~\cite{2009}, and has been accepted by researchers as suitable platform for evaluation and comparison of controllers~\cite{SIMUTORCS}.

Controllers are ranked according to performance during the championship, which consists of several races on different tracks divided into legs, spread through the conferences~\cite{2009}. They are scored using the Formula 1 point system\footnote{\url{http://www.formula1.com/}}. The software for SCR extends the TORCS architecture by structuring it as a clientâ€“server application, by incorporating real time processing and by physically separating the driver code and the race server through a sensors/actuators model abstraction layer~\cite{2009}. These changes provide an even more interesting environment for researchers by enabling any kind of controller implementation (as long as it can communicate via UDP connections) and defining a clear interface between controller and simulated car, which can be easily adapted for testing the controller with a different simulator or even a real car (provided the proper adaptations).

Car control is based on the drivers perceptions and the available actions; inputs are data about the car status (gear, fuel level, etc.), the race status (current lap, distance raced, etc.), and car surroundings (track borders, obstacles, etc.); outputs are steering, acceleration and breaking, gear~\cite{SCR}. There are 19 range finders available, these provide distance readings between the car axis and the track and their configuration can be customized by the developer~\cite{SCR}.

SCR controllers have been developed using AI techniques, such as neural networks, fuzzy logic, potential fields, and genetic algorithms~\cite{Loiacono:2012:LEA:2212908.2212953}. In the competition, the race track is initially unknown and it several drivers incorporate machine learning procedures to improve their performance~\cite{2009} advantage, which can essentially be \emph{online} or \emph{offline}. Online systems learn by moving about the environment and observing the results while offline ones learn solely by simulating actions within an internal model~\cite{mitchell_1997}.

Several solutions have been shown, including some imitating human behavior~\cite{Exp,5593318}. \emph{Mr. Racer}, which has won the last three championships (2011 to 2013), employs several heuristics and black-box optimization methods in a a modular structure in order to reproduce human-like mechanisms~\cite{MrRacer}, it applies a Covariance Matrix Adaptation Evolution Strategy (CMA-ES), to evolve parameters offline.

In the GECCO leg of the 2013 competition\footnote{\url{http://www.slideshare.net/dloiacono/gecco13scr}}, \emph{AUTOPIA}'s performance stands out. It implements a fuzzy architecture with gear, steering and speed control modules which are optimized offline by a genetic algorithm and an online learning mechanism for landmarking lane exit points to avoid leaving the track~\cite{AUTOPIA}.

Not surprisingly, other participants also use combinations of offline and online learning and modular approaches~\cite{2009,DIEGO,Exp}. Modularity has the clear advantage of independent development and optimization\cite{MrRacer,AUTOPIA2009}, and one of the simplest models for implementing different behaviors is a finite-state machine.

\subsection{Finite-State Machines}%
A FSM is a mathematical model with a finite number of states that can transition from one to another, and a FSM whose output values are determined solely by its current state is a Moore machine~\cite{Ajzerman}. FSMs have been widely used in AI application~\cite{Millington:2006:FSM}, mostly due to its inherent characteristics of flexibility, modularity, and intuitive behavior, among others~\cite{Buckland:2005:AI}.

States are usually implemented with hard-coded rules concerning a specific situation~\cite{Buckland:2005:AI}, which in turn demands small amounts of processor time, and can be easily implemented in different manners. The different driving behaviors can then be coded in parallel with less effort, and easily translated into different states of a FSM. Such approach has successfully been used in SCR~\cite{2009,DIEGO}.

The proper configuration of states and transitions, however, are a more complex problem. Several possible solutions exist, and machine learning techniques can readily be applied.

\subsection{Genetic Algorithms}

GAs are a particular kind of genetic optimization mechanism, inspired by evolutionary algorithms inspired by Darwin's theory of natural selection~\cite{GA}. They are probabilistic search procedures designed to work on large spaces~\cite{goldberg1988}, and have been successfully applied in many areas such as non-linear systems identification~\cite{GACTRL}, prosthesis development~\cite{GABIO}, economic dispatch~\cite{GAECO}, neuroevolution~\cite{stanley_real-time_2005}, data classifiers~\cite{pedrycz_genetic_2005}, and others.

GAs work by generating successor solutions by repeatedly mutating and recombining parts of the best currently known solutions, replacing a fraction of the population by offspring~\cite{mitchell_1997}. This is interesting because it works with little information on the problem's domain, the only requirements related specifically to the problem are a representation of a solution for a problem and a function for evaluating it's quality (fitness).

In the context of a self-driving car controller, a solution can be seen as a representation of the driver's parameters and the fitness a measure of its performance, considering speed, safety, fuel consumption, or whatever is the developer's interest. Considering SCR, the usual fitness is the distance driven during the given simulation time~\cite{2009}.
